/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */
%{
#include <stdio.h>
#include <stdlib.h>
#include "tree.h"

// Reference to the line number generated by the scanner
extern int yylineno;
extern PROGRAM *root;
// Reference to the yylex function to quiet a compiler warning
int yylex();


void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}
%}

/* Generate the yylloc structure used for storing line numbers with tokens */
%locations
/* Generate detailed error messages */
%error-verbose
%locations
%error-verbose

%code requires
{
	#include "tree.h"
}


%union {
	int intval;
	float floatval;
	char *stringval;
	char *identifier;
	char *type;
	EXP *exp;
	DCL *dcl;
	STMT *stmt;
	PROGRAM *program;
}

%type <program> program startProg dcls stmts
%type <stmt> stmt ifstmt
%type <dcl> dcl 
%type <exp> exp
%type <type> type

%token tUMINUS
%token tUNEGATE
%token tCOLON tSEMICOLON tPLUS tMINUS tMULTIPLY tDIVIDE;
%token tLEFTPAREN;
%token tRIGHTPAREN;
%token  tRIGHTBRACE;
%token  tLEFTBRACE;
%token  tASSIGN;
%token  tNEGATE;
%token  tEQUALS;
%token  tNOTEQUALS;
%token  tGREATEREQUALS;
%token  tLESSEQUALS;
%token  tGREATER;
%token  tLESS;
%token  tAND;
%token  tOR;
%token  tVAR;
%token  tFLOAT;
%token  tINT;
%token  tSTRING;
%token  tBOOLEAN;
%token  tIF;
%token  tELSE;
%token  tWHILE;
%token  tREAD;
%token  tPRINT;
%token  tTRUE;
%token  tFALSE;
%token <intval> tINTVAL
%token <floatval> tFLOATVAL
%token <stringval> tSTRINGVAL
%token <identifier> tIDENTIFIER 

%left tPLUS tMINUS
%left tMULTIPLY tDIVIDE
%left tUMINUS tUNEGATE

/* Start token (by default if this is missing it takes the first production */
%start startProg

%% 

startProg: program { root = $1; }
;

program:  %empty { $$ = NULL; }
		|dcls program { $$ = makeProgramD($1,$2); }
		| stmts program {$$ = makeProgramS($1,$2);}
;

dcls: %empty {$$ = NULL;}
	| dcl dcls {$$ = makeProgramD{$1,$2}; }
;	
	
stmts: %empty {$$ = NULL; }
	| stmt stmts {$$ = makeProgramS($1,$2);}
;

dcl: tVAR tIDENTIFIER tCOLON type tASSIGN exp tSEMICOLON { $$ = makeDclInit($2,}
	|
	tVAR tIDENTIFIER tCOLON type tSEMICOLON ;

	
type: tINT | tFLOAT | tSTRING | tBOOLEAN ;
stmt: tREAD tLEFTPAREN tIDENTIFIER tRIGHTPAREN tSEMICOLON |
	tPRINT tLEFTPAREN exp tRIGHTPAREN tSEMICOLON |
	tIDENTIFIER tASSIGN exp tSEMICOLON |
	tWHILE tLEFTPAREN exp tRIGHTPAREN tLEFTBRACE program tRIGHTBRACE |
	ifstmt ;
ifstmt: tIF tLEFTPAREN exp tRIGHTPAREN tLEFTBRACE program tRIGHTBRACE |
	tIF tLEFTPAREN exp tRIGHTPAREN tLEFTBRACE program tRIGHTBRACE tELSE tLEFTBRACE program tRIGHTBRACE |
	tIF tLEFTPAREN exp tRIGHTPAREN tLEFTBRACE program tRIGHTBRACE tELSE ifstmt ;
exp: tIDENTIFIER |
	tINTVAL | tFLOATVAL | tSTRINGVAL | tTRUE | tFALSE |
	tMINUS exp %prec tUMINUS | tNEGATE exp %prec tUNEGATE |
	exp tMULTIPLY exp | exp tDIVIDE exp | exp tPLUS exp | exp tMINUS exp |
	tLEFTPAREN exp tRIGHTPAREN |
	exp tGREATEREQUALS exp | exp tLESSEQUALS exp | exp tGREATER exp | exp tLESS exp |
	exp tEQUALS exp | exp tNOTEQUALS exp |
	exp tAND exp | exp tOR exp 
	;


%%

